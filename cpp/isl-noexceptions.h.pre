
#include <functional>
#include <string>
#include <set>
#include <map>
#include <stack>

namespace isl {
inline namespace noexceptions {

#define ISLPP_STRINGIZE_(X) #X
#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)

#define ISLPP_ASSERT(test, message)                          \
  do {                                                       \
    if (test)                                                \
      break;                                                 \
    fputs("Assertion \"" #test "\" failed at " __FILE__      \
      ":" ISLPP_STRINGIZE(__LINE__) "\n  " message "\n",     \
      stderr);                                               \
    abort();                                                 \
  } while (0)

class boolean {
private:
  isl_bool val;

  friend isl::boolean manage(isl_bool val);
  boolean(isl_bool val): val(val) {}
public:
  boolean()
      : val(isl_bool_error) {}

  /* implicit */ boolean(bool val)
      : val(val ? isl_bool_true : isl_bool_false) {}

  bool is_error() const { return val == isl_bool_error; }
  bool is_false() const { return val == isl_bool_false; }
  bool is_true() const { return val == isl_bool_true; }

  operator bool() const {
    ISLPP_ASSERT(!is_error(), "IMPLEMENTATION ERROR: Unhandled error state");
    return is_true();
  }

  boolean operator!() const {
    if (is_error())
      return *this;
    return !is_true();
  }
};

inline isl::boolean manage(isl_bool val) {
  return isl::boolean(val);
}

class ctx {
  isl_ctx *ptr;
public:
  /* implicit */ ctx(isl_ctx *ctx)
      : ptr(ctx) {}
  isl_ctx *release() {
    auto tmp = ptr;
    ptr = nullptr;
    return tmp;
  }
  isl_ctx *get() {
    return ptr;
  }
  isl_ctx *copy() {
    return ptr;
  }
};

enum class stat {
  ok = isl_stat_ok,
  error = isl_stat_error
};

enum class dim {
  cst = isl_dim_cst,
  param = isl_dim_param,
  in = isl_dim_in,
  out = isl_dim_out,
  set = isl_dim_set,
  div = isl_dim_div,
  all = isl_dim_all
};

std::map<std::uintptr_t, std::stack<std::string>> var_table;
static size_t next_var_id = 0;

std::string
makeVar(const void* address, std::string type_name)
{
    const std::uintptr_t ptr = reinterpret_cast<const std::uintptr_t>(address);
    if (!var_table.count(ptr))
    {
        var_table.insert(std::make_pair(ptr, std::stack<std::string>()));
    }
    std::string new_var_name = "p_" + next_var_id;
    var_table[ptr].push(new_var_name);
    ++next_var_id;
    return type_name + "* " + new_var_name;
}

std::string
getVar(const void* address, bool take)
{
    const std::uintptr_t ptr = reinterpret_cast<const std::uintptr_t>(address);
    assert(var_table.count(ptr));
    std::string top = var_table[ptr].top();
    if (take)
    {
        var_table[ptr].pop();
    }
    return top;
}

}
} // namespace isl
