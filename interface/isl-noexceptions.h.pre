#include <functional>
#include <string>

namespace isl {
inline namespace noexceptions {

#define ISLPP_STRINGIZE_(X) #X
#define ISLPP_STRINGIZE(X) ISLPP_STRINGIZE_(X)

#define ISLPP_ASSERT(test, message)                          \
  do {                                                       \
    if (test)                                                \
      break;                                                 \
    fputs("Assertion \"" #test "\" failed at " __FILE__      \
      ":" ISLPP_STRINGIZE(__LINE__) "\n  " message "\n",     \
      stderr);                                               \
  } while (0)

class boolean {
private:
  isl_bool val;

  friend isl::boolean manage(isl_bool val);
  boolean(isl_bool val): val(val) {}
public:
  boolean()
      : val(isl_bool_error) {}

  /* implicit */ boolean(bool val)
      : val(val ? isl_bool_true : isl_bool_false) {}

  bool is_error() const { return val == isl_bool_error; }
  bool is_false() const { return val == isl_bool_false; }
  bool is_true() const { return val == isl_bool_true; }

  operator bool() const {
    ISLPP_ASSERT(!is_error(), "IMPLEMENTATION ERROR: Unhandled error state");
    return is_true();
  }

  boolean operator!() const {
    if (is_error())
      return *this;
    return !is_true();
  }
};

inline isl::boolean manage(isl_bool val) {
  return isl::boolean(val);
}

class ctx {
  isl_ctx *ptr;
public:
  /* implicit */ ctx(isl_ctx *ctx)
      : ptr(ctx) {}
  isl_ctx *release() {
    auto tmp = ptr;
    ptr = nullptr;
    return tmp;
  }
  isl_ctx *get() {
    return ptr;
  }
};

enum class stat {
  ok = isl_stat_ok,
  error = isl_stat_error
};

isl_ctx *ptr_ctx = isl_ctx_alloc();
isl_space* ptr_space = isl_space_set_alloc(ptr_ctx, 1, 0);
isl_set* pointers = isl_set_empty(ptr_space);

const void*
getVar(const void* address)
{
    uintptr_t ptr = reinterpret_cast<std::uintptr_t>(address);
    isl_val* ptr_val = isl_val_int_from_ui(ptr_ctx, ptr);
    isl_pw_aff* ptr_pw_aff = isl_pw_aff_val_on_domain(pointers, ptr_val);
    isl_set* ptr_set = isl_set_from_pw_aff(ptr_pw_aff);
    pointers = isl_set_union(pointers, ptr_set);
    printf(isl_set_to_str(pointers));
    return address;
}

}
} // namespace isl
